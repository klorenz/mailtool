// Generated by CoffeeScript 1.9.1
(function() {
  var CSON, MailTool, MailToolMissingFieldError, doT, extend, fs, getImapClient, getUserHome, isUpperCase, keys, main, markdown, nodeMailerConfig, nodemailer, path, ref, signature,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  CSON = require('season');

  markdown = require('nodemailer-markdown').markdown;

  doT = require('nodemailer-dot-templates').doT;

  signature = require('nodemailer-signature').signature;

  nodemailer = require('nodemailer');

  ref = require('underscore'), keys = ref.keys, extend = ref.extend;

  fs = require('fs');

  path = require('path');


  /*
  work around a bug in tcp-socket.  It does not detect atom-shell
  in right way and uses wrong tcp,tls factory and fails :(
   */

  getImapClient = function(logLevel) {
    var ImapClient, axe, orig_require, tcp_socket;
    if (logLevel == null) {
      logLevel = null;
    }
    if (getImapClient.ImapClient) {
      return getImapClient.ImapClient;
    }
    axe = require('axe-logger');
    axe.logLevel = logLevel != null ? logLevel : axe.ERROR;
    tcp_socket = require('tcp-socket');
    orig_require = module.constructor.prototype.require;
    module.constructor.prototype.require = function(name) {
      if (name === 'tcp-socket') {
        return tcp_socket;
      } else if (name === 'axe-logger') {
        return axe;
      } else {
        return orig_require.call(this, name);
      }
    };
    ImapClient = require('imap-client');
    module.constructor.prototype.require = orig_require;
    getImapClient.ImapClient = ImapClient;
    return ImapClient;
  };

  getUserHome = function() {
    return process.env[(process.platform === 'win32') && 'USERPROFILE' || 'HOME'];
  };

  isUpperCase = function(s) {
    return s.toUpperCase() === s;
  };

  MailToolMissingFieldError = (function(superClass) {
    extend1(MailToolMissingFieldError, superClass);

    function MailToolMissingFieldError(field1) {
      this.field = field1;
      MailToolMissingFieldError.__super__.constructor.apply(this, arguments);
      this.message = "Missing field '" + this.field + "' in envelope";
    }

    MailToolMissingFieldError.prototype.__toString = function() {
      return this.message;
    };

    return MailToolMissingFieldError;

  })(Error);

  MailTool = (function() {
    function MailTool(config, transport) {
      var k, ref1, v;
      if (!config) {
        config = "~/.mailtool.cson";
      }
      if (typeof config === "string") {
        this.loadConfig(config);
      } else {
        this.config = config;
      }
      if (!('default' in this.config)) {
        ref1 = this.config;
        for (k in ref1) {
          v = ref1[k];
          this.config["default"] = k;
          break;
        }
      }
      if (typeof this.config["default"] === "string") {
        this.config["default"] = this.config[this.config["default"]];
      }
      this.transport = transport;
      this.required = ['subject', 'to'];
    }

    MailTool.prototype.getConfig = function(name) {
      var cfg, m, result, subcfg;
      if (!name) {
        result = [];
        for (name in this.config) {
          if (typeof this.config[name] === "string") {
            result.push({
              name: name,
              alias: this.config[name]
            });
          } else {
            result.push({
              name: name
            });
          }
        }
      }
      cfg = name;
      subcfg = null;
      if (m = name.match(/(.*)\.(.*)/)) {
        cfg = m[1];
        subcfg = m[2];
      }
      while (typeof cfg === "string") {
        cfg = this.config[cfg];
      }
      if (subcfg) {
        return cfg[subcfg];
      }
      return cfg;
    };

    MailTool.prototype.getMailerConfig = function(name, mailer) {
      var cfg, k, opts, v;
      if (mailer == null) {
        mailer = null;
      }
      cfg = this.getConfig(name);
      if (!mailer) {
        opts = {};
        for (k in cfg) {
          v = cfg[k];
          if (k === "mailbox") {
            continue;
          }
          if (k === "transport") {
            continue;
          }
          opts[k] = v;
        }
        return opts;
      }
      return cfg[mailer];
    };

    MailTool.prototype.getImapConnection = function(options) {
      var config, configFileDir, connectImap, host, logLevel, name, passwdFile, passwdFunction, port;
      if (options == null) {
        options = {};
      }
      name = options.name, config = options.config, host = options.host, port = options.port, logLevel = options.logLevel;
      name = config || name;
      if (!(name || host)) {
        name = 'default';
      }
      connectImap = (function(_this) {
        return function(name, options) {
          var ImapClient;
          if (!(name in _this.imapConnections)) {
            ImapClient = getImapClient(logLevel);
            _this.imapConnections[name] = new ImapClient(options);
          }
          return _this.imapConnections[name];
        };
      })(this);
      if (name) {
        options = extend({}, this.config[name].mailbox, options);
        options.auth = extend({}, this.config[name].mailbox.auth, options.auth || {});
        if (typeof config.auth.pass === "function") {
          passwdFunction = options.auth.pass;
          options.auth.pass((function(_this) {
            return function(passwd, callback) {
              options.auth.pass = passwd;
              return callback(connectImap(name, options));
            };
          })(this));
        }
        configFileDir = path.dirname(this.config[name].configFileName);
        passwdFile = path.resolve(configFileDir, config.auth.pass);
        if (fs.existsSync(passwdFile)) {
          options.auth.pass = fs.readFileSync(passwdFile).toString().trim();
        }
      } else {
        name = config.auth.user + "@" + host + ":" + port;
      }
      return connectImap(name, options);
    };

    MailTool.prototype.closeImapConnections = function(callback) {
      var imap, imapConnections, name, ref1;
      imapConnections = this.imapConnections;
      ref1 = this.imapConnections;
      for (name in ref1) {
        imap = ref1[name];
        imap.logout().then((function(_this) {
          return function() {
            return delete imapConnections[name];
          };
        })(this));
      }
      return this.imapConnections = {};
    };

    MailTool.prototype.getConfigFileName = function() {
      return this.config.configFileName;
    };

    MailTool.prototype.saveConfig = function(fileName) {
      if (!fileName) {
        fileName = this.getConfigFileName();
      }
      return this.writeConfig(fileName, this.config);
    };

    MailTool.prototype.resolveFileName = function(fileName) {
      return fileName.replace(/^~/, getUserHome());
    };

    MailTool.prototype.loadConfig = function(fileName) {
      if (this.watcher) {
        this.watcher.close();
      }
      this.closeImapConnections();
      this.config = this.readConfig(fileName);
      return this.watcher = fs.watch(this.getConfigFileName(), {
        persistent: false
      }, (function(_this) {
        return function() {
          return _this.loadConfig();
        };
      })(this));
    };

    MailTool.prototype.readConfig = function(fileName) {
      var config;
      fileName = this.resolveFileName(fileName);
      config = CSON.readFileSync(fileName);
      config.configFileName = fileName;
      return config;
    };

    MailTool.prototype.writeConfig = function(fileName, config) {
      var configFileName;
      configFileName = null;
      try {
        if ('configFileName' in config) {
          configFileName = config.configFileName;
          delete config.configFileName;
        }
        return CSON.writeFileSync(this.resolveFileName(fileName), config);
      } finally {
        if (configFileName != null) {
          config.configFileName = configFileName;
        }
      }
    };

    MailTool.prototype.parseMessageText = function(text) {
      var body, d, header, i, key, len, line, m, opts, ref1, ref2, value;
      if (!(m = text.match(/^([\w\-]+[ \t]*:\s[\s\S]*?)\r?\n\r?\n([\s\S]*)/))) {
        return {
          text: text
        };
      }
      header = m[1] + "\n";
      body = m[2];
      opts = {};
      ref1 = header.match(/^\S.*\n(?:[ \t].*\n)*/gm);
      for (i = 0, len = ref1.length; i < len; i++) {
        line = ref1[i];
        line = line.replace(/\s*$/, '');
        try {
          d = CSON.parse(line);
          extend(opts, d);
        } catch (_error) {
          try {
            if (!line.match(/\n/)) {
              ref2 = line.match(/^([\w\-]+)\s*:\s+(.*)/).slice(1), key = ref2[0], value = ref2[1];
              opts[key] = value;
            } else {
              opts = null;
              break;
            }
          } catch (_error) {
            opts = null;
            break;
          }
        }
      }
      if (opts != null) {
        opts.text = body;
        return opts;
      } else {
        throw new Error("Cannot parse header");
      }
    };

    MailTool.prototype.compile = function(options, callback) {
      var cfgName, err, field, i, key, len, missing, ref1, ref2, value;
      extend(options, this.parseMessageText(options.text));
      cfgName = options.config || options.name || 'default.default';
      if (!cfgName.match(/\./)) {
        throw new Error("invalid configuration name (must contain a .)");
      }
      ref1 = this.getConfig(cfgName);
      for (key in ref1) {
        value = ref1[key];
        if (!(key in options)) {
          options[key] = value;
        } else if (typeof options[key] === "object" && typeof value === "object") {
          options[key] = extend({}, value, options[key]);
        }
      }
      if (options.markdown === true) {
        options.markdown = options.text;
        delete options.text;
      }
      missing = [];
      ref2 = this.required;
      for (i = 0, len = ref2.length; i < len; i++) {
        field = ref2[i];
        if (!(field in options)) {
          missing.push(field);
        }
      }
      if (missing.length) {
        if (options.optionDialog) {
          return options.optionDialog({
            missing: missing,
            options: options
          }, function() {
            return typeof callback === "function" ? callback(options) : void 0;
          });
        }
        err = new MailToolMissingFieldError(missing);
        if (callback) {
          return process.nextTick(function() {
            return callback(err);
          });
        } else {
          throw err;
        }
      }
      return typeof callback === "function" ? callback(options) : void 0;
    };

    MailTool.prototype.sendMail = function(config, callback) {
      var setupTransporter;
      config = extend({}, config);
      setupTransporter = (function(_this) {
        return function(done) {
          var auth, cfgName, configFileDir, m, passwdFile, transport, transporter;
          if (!config.transport) {
            cfgName = config.config || config.name || 'default';
            if (m = cfgName.match(/(.*)\.(.*)/)) {
              cfgName = m[1];
            }
            config.transport = extend({}, _this.getConfig(cfgName).transport);
            config.transport.auth = auth = extend({}, config.transport.auth);
            configFileDir = path.dirname(_this.getConfigFileName());
            passwdFile = path.resolve(configFileDir, auth.pass);
            if (fs.existsSync(passwdFile)) {
              auth.pass = fs.readFileSync(passwdFile).toString().trim();
            }
            if (config.transport.rejectUnauthorized === false) {
              process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
            }
            transport = (require("nodemailer-smtp-transport"))(config.transport);
            transporter = nodemailer.createTransport(transport);
          } else if (_this.transport.sendMail) {
            transporter = _this.transport;
          } else {
            transport = _this.transport(config.transport);
            transporter = nodemailer.createTransport(transport);
          }
          return done(transporter);
        };
      })(this);
      return this.compile(config, (function(_this) {
        return function() {
          return setupTransporter(function(transporter) {
            var theMail;
            theMail = null;
            transporter.use('compile', doT());
            transporter.use('compile', signature());
            transporter.use('compile', markdown(config));
            transporter.use('compile', function(mail, callback) {
              theMail = mail;
              console.log("message compiled", theMail);
              return callback();
            });
            return transporter.sendMail(config, callback);
          });
        };
      })(this));
    };

    return MailTool;

  })();

  nodeMailerConfig = function() {
    var args, mailtool;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    mailtool = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(MailTool, args, function(){});
    return function(options, done) {
      return mailtool.compile(options, done);
    };
  };

  main = function() {
    var mt;
    mt = new MailTool("~/.mailtool.cson");
    return mt.connectImap('default').then((function(_this) {
      return function() {
        return mt.imap.listWellKnownFolders().then(function(folderInfo) {
          return console.log(folderInfo);
        });
      };
    })(this));
  };

  module.exports = {
    MailTool: MailTool,
    nodeMailerConfig: nodeMailerConfig,
    main: main,
    MailToolMissingFieldError: MailToolMissingFieldError
  };

}).call(this);
